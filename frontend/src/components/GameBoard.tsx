import React, { useState, useEffect, useRef } from 'react';
import '../styles/GameBoard.css';
import SwipeConnector from './core/SwipeConnector';
import { Toast } from 'antd-mobile';

// ËÆæÁΩÆÂõæÊ†áSVGÁªÑ‰ª∂
const SettingsIcon = () => (
  <svg className="settings-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
  </svg>
);

// ËÉΩÈáèÂõæÊ†áSVGÁªÑ‰ª∂
const EnergyIcon = () => (
  <svg className="energy-icon" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
  </svg>
);

interface GameBoardProps {
  rows: number;
  cols: number;
  onScoreChange: (score: number) => void;
  onEnergyChange: (energy: number) => void;
  onOpenSettings: () => void;
}

interface Block {
  id: string;
  color: string;
  type: 'normal' | 'bomb' | 'rainbow' | 'line';
  selected: boolean;
}

const GameBoard: React.FC<GameBoardProps> = ({ 
  rows = 8, 
  cols = 8, 
  onScoreChange, 
  onEnergyChange,
  onOpenSettings
}) => {
  const [blocks, setBlocks] = useState<Block[][]>([]);
  const [score, setScore] = useState<number>(0);
  const [moves, setMoves] = useState<number>(20);
  const [energy, setEnergy] = useState<number>(0);
  const [combo, setCombo] = useState<number>(0);
  const [gameOver, setGameOver] = useState<boolean>(false);
  const [selectedBlocks, setSelectedBlocks] = useState<{row: number, col: number}[]>([]);
  const [isSwipeEnabled, setIsSwipeEnabled] = useState<boolean>(true);
  const [blockColors, setBlockColors] = useState<string[][]>([]);
  const [specialBlocks, setSpecialBlocks] = useState<{row: number, col: number, type: string}[]>([]);
  const [showHapticFeedback, setShowHapticFeedback] = useState<boolean>(false);
  const [isAnimating, setIsAnimating] = useState<boolean>(false);
  const [energyBurstReady, setEnergyBurstReady] = useState<boolean>(false);
  
  const boardRef = useRef<HTMLDivElement>(null);
  const blockSize = useRef<number>(60); // ÈªòËÆ§ÊñπÂùóÂ§ßÂ∞èÔºå‰ºöÊ†πÊçÆÂ±èÂπïËá™ÈÄÇÂ∫îË∞ÉÊï¥

  // È¢úËâ≤ÂàóË°® - ‰ºòÂåñÂêéÁöÑËâ≤ÂΩ©ÊñπÊ°àÔºåÊõ¥ÂçèË∞É‰∏îÂáèÂ∞ëËßÜËßâÁñ≤Âä≥
  const colors = [
    '#FF6B6B', // ÊüîÂíåÁ∫¢
    '#4ECDC4', // ËñÑËç∑Áªø
    '#45B7D1', // Â§©Ëìù
    '#FFC857', // Ê∏©ÊöñÈªÑ
    '#A882DD', // Ê∑°Á¥´
    '#FF9A76'  // ÁèäÁëöÊ©ô
  ];
  
  // ÂàùÂßãÂåñÊ∏∏ÊàèÊùø
  useEffect(() => {
    initializeBoard();
    
    // ËÆ°ÁÆóÈÄÇÂêàÂ±èÂπïÁöÑÊñπÂùóÂ§ßÂ∞è
    const updateBlockSize = () => {
      if (boardRef.current) {
        const boardWidth = boardRef.current.clientWidth - 24; // ÂáèÂéªÂÜÖËæπË∑ù
        const calculatedSize = Math.floor((boardWidth - (cols - 1) * 8) / cols); // ËÄÉËôëÈó¥Èöô
        blockSize.current = calculatedSize;
      }
    };
    
    updateBlockSize();
    window.addEventListener('resize', updateBlockSize);
    
    // Ê∑ªÂä†Êñ∞ÊâãÂºïÂØº
    if (!localStorage.getItem('gameIntroShown')) {
      setTimeout(() => {
        Toast.show({
          content: 'ÊªëÂä®ËøûÊé•3‰∏™ÊàñÊõ¥Â§öÁõ∏ÂêåÈ¢úËâ≤ÁöÑÊñπÂùóÊù•Ê∂àÈô§ÂÆÉ‰ª¨',
          position: 'center',
          duration: 3000,
        });
        localStorage.setItem('gameIntroShown', 'true');
      }, 1000);
    }
    
    return () => {
      window.removeEventListener('resize', updateBlockSize);
    };
  }, []);

  // ÁõëÂê¨ËÉΩÈáèÂèòÂåñ
  useEffect(() => {
    onEnergyChange(energy);
    
    // ÂΩìËÉΩÈáèËææÂà∞100%Êó∂ÔºåÊòæÁ§∫ËÉΩÈáèÁàÜÂèëÊåâÈíÆ
    setEnergyBurstReady(energy >= 100);
  }, [energy, onEnergyChange]);

  // ÁõëÂê¨ÂàÜÊï∞ÂèòÂåñ
  useEffect(() => {
    onScoreChange(score);
    
    // Êõ¥Êñ∞ÊúÄÈ´òÂàÜ
    const highScore = localStorage.getItem('highScore');
    if (!highScore || score > parseInt(highScore)) {
      localStorage.setItem('highScore', score.toString());
    }
  }, [score, onScoreChange]);

  // ÂàùÂßãÂåñÊ∏∏ÊàèÊùø
  const initializeBoard = () => {
    const newBlocks: Block[][] = [];
    const newBlockColors: string[][] = [];
    const newSpecialBlocks: {row: number, col: number, type: string}[] = [];
    
    for (let i = 0; i < rows; i++) {
      const row: Block[] = [];
      const colorRow: string[] = [];
      
      for (let j = 0; j < cols; j++) {
        const block = createRandomBlock();
        row.push(block);
        colorRow.push(block.color);
        
        if (block.type !== 'normal') {
          newSpecialBlocks.push({
            row: i,
            col: j,
            type: block.type
          });
        }
      }
      
      newBlocks.push(row);
      newBlockColors.push(colorRow);
    }
    
    setBlocks(newBlocks);
    setBlockColors(newBlockColors);
    setSpecialBlocks(newSpecialBlocks);
    setScore(0);
    setMoves(20);
    setEnergy(0);
    setCombo(0);
    setGameOver(false);
    setSelectedBlocks([]);
    setIsSwipeEnabled(true);
    setIsAnimating(false);
    setEnergyBurstReady(false);
  };

  // ÂàõÂª∫ÈöèÊú∫ÊñπÂùó
  const createRandomBlock = (): Block => {
    const randomColor = colors[Math.floor(Math.random() * colors.length)];
    const randomType = Math.random() < 0.9 ? 'normal' : 
                      (Math.random() < 0.5 ? 'bomb' : 
                      (Math.random() < 0.5 ? 'rainbow' : 'line'));
    
    return {
      id: Math.random().toString(36).substr(2, 9),
      color: randomColor,
      type: randomType,
      selected: false
    };
  };

  // Â§ÑÁêÜÊªëÂä®Ë∑ØÂæÑÂÆåÊàê
  const handlePathComplete = (path: {row: number, col: number}[]) => {
    if (gameOver || moves <= 0 || path.length < 3 || isAnimating) return;
    
    // ËÆæÁΩÆÂä®ÁîªÁä∂ÊÄÅÔºåÈò≤Ê≠¢ÈáçÂ§çËß¶Âèë
    setIsAnimating(true);
    
    // Ëß¶ÂèëËß¶ÊÑüÂèçÈ¶à
    triggerHapticFeedback();
    
    // Êõ¥Êñ∞ÈÄâ‰∏≠ÁöÑÊñπÂùó
    setSelectedBlocks(path);
    
    // ÊòæÁ§∫ËøûÂáªÊèêÁ§∫
    if (combo > 0) {
      Toast.show({
        content: `${combo + 1}ËøûÂáªÔºÅ`,
        position: 'center',
        duration: 1000,
      });
    }
    
    // Âª∂ËøüÊ∂àÈô§ÔºåËÆ©Áé©ÂÆ∂ÁúãÂà∞ËøûÁ∫øÊïàÊûú
    setTimeout(() => {
      eliminateBlocks(path);
    }, 500);
  };

  // Ëß¶ÂèëËß¶ÊÑüÂèçÈ¶à
  const triggerHapticFeedback = () => {
    // Â¶ÇÊûúËÆæÂ§áÊîØÊåÅÔºåËß¶ÂèëÊåØÂä®
    if (navigator.vibrate) {
      navigator.vibrate(20);
    }
    
    // ÊòæÁ§∫ËßÜËßâÂèçÈ¶à
    setShowHapticFeedback(true);
    setTimeout(() => setShowHapticFeedback(false), 100);
  };

  // Ê∂àÈô§ÈÄâ‰∏≠ÁöÑÊñπÂùó
  const eliminateBlocks = (path: {row: number, col: number}[]) => {
    if (path.length < 3) {
      setSelectedBlocks([]);
      setIsAnimating(false);
      return;
    }
    
    // ËÆ°ÁÆóÂæóÂàÜ
    const baseScore = path.length * 10;
    const comboMultiplier = combo > 0 ? combo * 0.5 + 1 : 1;
    const newScore = score + Math.floor(baseScore * comboMultiplier);
    
    // Êõ¥Êñ∞ÂàÜÊï∞ - Ê∑ªÂä†Âä®ÁîªÊïàÊûú
    const scoreElement = document.querySelector('.score span');
    if (scoreElement) {
      scoreElement.classList.add('score-change');
      setTimeout(() => {
        scoreElement.classList.remove('score-change');
      }, 500);
    }
    setScore(newScore);
    
    // Êõ¥Êñ∞ËÉΩÈáè
    const energyGain = path.length * 5;
    const newEnergy = Math.min(energy + energyGain, 100);
    setEnergy(newEnergy);
    
    // Êõ¥Êñ∞ËøûÂáª
    setCombo(combo + 1);
    
    // ÂàõÂª∫Êñ∞ÁöÑÊñπÂùóÊï∞ÁªÑÂíåÈ¢úËâ≤Êï∞ÁªÑ
    const newBlocks = [...blocks];
    const newBlockColors = [...blockColors];
    const newSpecialBlocks: {row: number, col: number, type: string}[] = [];
    
    // Â§ÑÁêÜÁâπÊÆäÊñπÂùóÊïàÊûú
    path.forEach(pos => {
      const block = newBlocks[pos.row][pos.col];
      
      if (block.type === 'bomb') {
        // ÁÇ∏ÂºπÊïàÊûúÔºöÊ∂àÈô§Âë®Âõ¥ÁöÑÊñπÂùó
        for (let i = Math.max(0, pos.row - 1); i <= Math.min(rows - 1, pos.row + 1); i++) {
          for (let j = Math.max(0, pos.col - 1); j <= Math.min(cols - 1, pos.col + 1); j++) {
            if (i !== pos.row || j !== pos.col) {
              const newBlock = createRandomBlock();
              newBlocks[i][j] = newBlock;
              newBlockColors[i][j] = newBlock.color;
              
              if (newBlock.type !== 'normal') {
                newSpecialBlocks.push({
                  row: i,
                  col: j,
                  type: newBlock.type
                });
              }
            }
          }
        }
        
        // ÊòæÁ§∫ÁÇ∏ÂºπÊïàÊûúÊèêÁ§∫
        Toast.show({
          content: 'üí£ ÁàÜÁÇ∏ÔºÅ',
          position: 'center',
          duration: 1000,
        });
      } else if (block.type === 'line') {
        // Áõ¥Á∫øÊïàÊûúÔºöÊ∂àÈô§Âêå‰∏ÄË°åÊàñÂàóÁöÑÊñπÂùó
        for (let i = 0; i < rows; i++) {
          if (i !== pos.row) {
            const newBlock = createRandomBlock();
            newBlocks[i][pos.col] = newBlock;
            newBlockColors[i][pos.col] = newBlock.color;
            
            if (newBlock.type !== 'normal') {
              newSpecialBlocks.push({
                row: i,
                col: pos.col,
                type: newBlock.type
              });
            }
          }
        }
        for (let j = 0; j < cols; j++) {
          if (j !== pos.col) {
            const newBlock = createRandomBlock();
            newBlocks[pos.row][j] = newBlock;
            newBlockColors[pos.row][j] = newBlock.color;
            
            if (newBlock.type !== 'normal') {
              newSpecialBlocks.push({
                row: pos.row,
                col: j,
                type: newBlock.type
              });
            }
          }
        }
        
        // ÊòæÁ§∫Áõ¥Á∫øÊïàÊûúÊèêÁ§∫
        Toast.show({
          content: '‚ö° Èó™ÁîµÊ∏ÖÈô§ÔºÅ',
          position: 'center',
          duration: 1000,
        });
      }
      
      // ÈáçÊñ∞ÁîüÊàêË¢´Ê∂àÈô§ÁöÑÊñπÂùó
      const newBlock = createRandomBlock();
      newBlocks[pos.row][pos.col] = newBlock;
      newBlockColors[pos.row][pos.col] = newBlock.color;
      
      if (newBlock.type !== 'normal') {
        newSpecialBlocks.push({
          row: pos.row,
          col: pos.col,
          type: newBlock.type
        });
      }
    });
    
    // Êõ¥Êñ∞ÊñπÂùóÊï∞ÁªÑÂíåÈ¢úËâ≤Êï∞ÁªÑ
    setBlocks(newBlocks);
    setBlockColors(newBlockColors);
    setSpecialBlocks(newSpecialBlocks);
    
    // ÂáèÂ∞ëÁßªÂä®Ê¨°Êï∞
    const newMoves = moves - 1;
    setMoves(newMoves);
    
    // Ê£ÄÊü•Ê∏∏ÊàèÊòØÂê¶ÁªìÊùü
    if (newMoves <= 0) {
      setGameOver(true);
      setIsSwipeEnabled(false);
      
      // ÊòæÁ§∫Ê∏∏ÊàèÁªìÊùüÂºπÁ™ó
      setTimeout(() => {
        showGameOverModal();
      }, 1000);
    }
    
    // ÈáçÁΩÆÈÄâÊã©
    setSelectedBlocks([]);
    
    // Âª∂ËøüÈáçÁΩÆÂä®ÁîªÁä∂ÊÄÅÔºåÁ°Æ‰øùÂä®ÁîªÊúâË∂≥Â§üÊó∂Èó¥Êí≠Êîæ
    setTimeout(() => {
      setIsAnimating(false);
    }, 300);
  };

  // ‰ΩøÁî®ËÉΩÈáèÁàÜÂèë
  const useEnergyBurst = () => {
    if (energy < 100 || isAnimating) return;
    
    // ËÆæÁΩÆÂä®ÁîªÁä∂ÊÄÅ
    setIsAnimating(true);
    
    // Ëß¶ÂèëËß¶ÊÑüÂèçÈ¶à
    triggerHapticFeedback();
    
    // ÊòæÁ§∫ËÉΩÈáèÁàÜÂèëÊïàÊûúÊèêÁ§∫
    Toast.show({
      content: '‚ö°‚ö°‚ö° ËÉΩÈáèÁàÜÂèëÔºÅ',
      position: 'center',
      duration: 1500,
    });
    
    // ÈöèÊú∫Ê∂àÈô§‰∏ÄÂçäÁöÑÊñπÂùó
    const newBlocks = [...blocks];
    const newBlockColors = [...blockColors];
    const newSpecialBlocks: {row: number, col: number, type: string}[] = [];
    
    const totalBlocks = rows * cols;
    const blocksToEliminate = Math.floor(totalBlocks / 2);
    
    let eliminated = 0;
    while (eliminated < blocksToEliminate) {
      const randomRow = Math.floor(Math.random() * rows);
      const randomCol = Math.floor(Math.random() * cols);
      
      // ÈáçÊñ∞ÁîüÊàêÈöèÊú∫ÊñπÂùó
      const newBlock = createRandomBlock();
      newBlocks[randomRow][randomCol] = newBlock;
      newBlockColors[randomRow][randomCol] = newBlock.color;
      
      if (newBlock.type !== 'normal') {
        newSpecialBlocks.push({
          row: randomRow,
          col: randomCol,
          type: newBlock.type
        });
      }
      
      eliminated++;
    }
    
    // Êõ¥Êñ∞ÊñπÂùóÊï∞ÁªÑÂíåÈ¢úËâ≤Êï∞ÁªÑ
    setBlocks(newBlocks);
    setBlockColors(newBlockColors);
    setSpecialBlocks(newSpecialBlocks);
    
    // Â¢ûÂä†ÂàÜÊï∞
    setScore(score + 500);
    
    // ÈáçÁΩÆËÉΩÈáè
    setEnergy(0);
    setEnergyBurstReady(false);
    
    // Âª∂ËøüÈáçÁΩÆÂä®ÁîªÁä∂ÊÄÅ
    setTimeout(() => {
      setIsAnimating(false);
    }, 800);
  };

  // ÊòæÁ§∫Ê∏∏ÊàèÁªìÊùüÂºπÁ™ó
  const showGameOverModal = () => {
    // Ê∏∏ÊàèÁªìÊùüÂºπÁ™óÈÄªËæë
    // ËøôÈáåÂèØ‰ª•‰ΩøÁî®DialogÁªÑ‰ª∂ÊàñËá™ÂÆö‰πâÂºπÁ™ó
  };

  // ÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
  const restartGame = () => {
    // ÊòæÁ§∫ÈáçÊñ∞ÂºÄÂßãÊèêÁ§∫
    Toast.show({
      content: 'Ê∏∏ÊàèÈáçÊñ∞ÂºÄÂßãÔºÅ',
      position: 'center',
      duration: 1000,
    });
    
    // ÂàùÂßãÂåñÊ∏∏Êàè
    initializeBoard();
  };

  // Ê∏≤ÊüìÊñπÂùó
  const renderBlock = (block: Block, row: number, col: number) => {
    let icon = '';
    let iconClass = '';
    
    if (block.type === 'bomb') {
      icon = 'üí£';
      iconClass = 'bomb-icon';
    } else if (block.type === 'rainbow') {
      icon = 'üåà';
      iconClass = 'rainbow-icon';
    } else if (block.type === 'line') {
      icon = '‚ö°';
      iconClass = 'line-icon';
    }
    
    const isSelected = selectedBlocks.some(b => b.row === row && b.col === col);
    
    return (
      <div 
        key={`${row}-${col}`}
        className={`block ${isSelected ? 'selected' : ''}`}
        style={{ 
          backgroundColor: block.color,
          width: `${blockSize.current}px`,
          height: `${blockSize.current}px`
        }}
        data-row={row}
        data-col={col}
      >
        {icon && <span className={`special-icon ${iconClass}`}>{icon}</span>}
      </div>
    );
  };

  return (
    <div className="game-container">
      <div className="game-header">
        <button 
          className="settings-button"
          onClick={onOpenSettings}
          aria-label="ËÆæÁΩÆ"
        >
          <SettingsIcon />
        </button>
      </div>

      <div className="game-info">
        <div className="score">
          <span className="info-label">ÂàÜÊï∞</span>
          <span>{score}</span>
        </div>
        <div className="moves">
          <span className="info-label">Ê≠•Êï∞</span>
          <span>{moves}</span>
        </div>
        <div className="combo">
          <span className="info-label">ËøûÂáª</span>
          <span>{combo}x</span>
        </div>
      </div>

      <div className="energy-bar-container">
        <div 
          className="energy-bar" 
          style={{ width: `${energy}%` }}
        />
        {energyBurstReady && (
          <button 
            className="energy-burst-button"
            onClick={useEnergyBurst}
            disabled={isAnimating}
          >
            <EnergyIcon />
          </button>
        )}
      </div>

      <div 
        className="game-board"
        style={{ 
          gridTemplateColumns: `repeat(${cols}, 1fr)`,
          gridTemplateRows: `repeat(${rows}, 1fr)`
        }}
        ref={boardRef}
      >
        {blocks.map((row, rowIndex) => (
          row.map((block, colIndex) => (
            renderBlock(block, rowIndex, colIndex)
          ))
        ))}
        
        <SwipeConnector 
          rows={rows}
          cols={cols}
          blockColors={blockColors}
          blockSize={blockSize.current}
          onPathComplete={handlePathComplete}
          isEnabled={isSwipeEnabled && !isAnimating && !gameOver}
          specialBlocks={specialBlocks}
        />
      </div>

      {showHapticFeedback && (
        <div className="haptic-feedback" />
      )}

      {gameOver && (
        <div className="game-over-overlay">
          <div className="game-over-modal">
            <h2>Ê∏∏ÊàèÁªìÊùü</h2>
            <p>ÊúÄÁªàÂæóÂàÜ: {score}</p>
            <button onClick={restartGame}>ÂÜçÊù•‰∏ÄÂ±Ä</button>
          </div>
        </div>
      )}
    </div>
  );
};

export default GameBoard;
