import React, { useState, useEffect, useCallback } from 'react';
import '../styles/GameBoard.css';

// ÊñπÂùóÁ±ªÂûãÂÆö‰πâ
interface Block {
  id: number;
  type: number;
  special: string | null;
  x: number;
  y: number;
  selected: boolean;
}

// ÁâπÊÆäÊñπÂùóÁ±ªÂûã
type SpecialType = null | 'bomb' | 'rainbow' | 'line';

// Ê∏∏ÊàèÈù¢ÊùøÂ±ûÊÄß
interface GameBoardProps {
  rows: number;
  cols: number;
  onScoreChange: (score: number) => void;
  onEnergyChange: (energy: number) => void;
}

const GameBoard: React.FC<GameBoardProps> = ({ rows, cols, onScoreChange, onEnergyChange }) => {
  // Ê∏∏ÊàèÁä∂ÊÄÅ
  const [blocks, setBlocks] = useState<Block[]>([]);
  const [selectedBlocks, setSelectedBlocks] = useState<Block[]>([]);
  const [score, setScore] = useState<number>(0);
  const [energy, setEnergy] = useState<number>(0);
  const [combo, setCombo] = useState<number>(0);
  const [gameOver, setGameOver] = useState<boolean>(false);
  const [movesLeft, setMovesLeft] = useState<number>(20);

  // È¢úËâ≤Êò†Â∞Ñ
  const colorMap = [
    '#FF5252', // Á∫¢Ëâ≤
    '#4CAF50', // ÁªøËâ≤
    '#2196F3', // ËìùËâ≤
    '#FFEB3B', // ÈªÑËâ≤
    '#9C27B0', // Á¥´Ëâ≤
    '#FF9800', // Ê©ôËâ≤
  ];

  // ÁâπÊÆäÊñπÂùóÂõæÊ†á
  const specialIcons = {
    bomb: 'üí£',
    rainbow: 'üåà',
    line: '‚ö°',
  };

  // ÂàùÂßãÂåñÊ∏∏ÊàèÈù¢Êùø
  const initializeBoard = useCallback(() => {
    const newBlocks: Block[] = [];
    let id = 0;
    
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        // ÈöèÊú∫ÁîüÊàêÊñπÂùóÁ±ªÂûãÔºàÈ¢úËâ≤Ôºâ
        const type = Math.floor(Math.random() * 6);
        
        // ÈöèÊú∫ÁîüÊàêÁâπÊÆäÊñπÂùóÔºà5%Ê¶ÇÁéáÔºâ
        let special: SpecialType = null;
        const specialRand = Math.random();
        if (specialRand < 0.02) {
          special = 'bomb';
        } else if (specialRand < 0.04) {
          special = 'rainbow';
        } else if (specialRand < 0.05) {
          special = 'line';
        }
        
        newBlocks.push({
          id: id++,
          type,
          special,
          x,
          y,
          selected: false
        });
      }
    }
    
    setBlocks(newBlocks);
    setSelectedBlocks([]);
    setScore(0);
    setEnergy(0);
    setCombo(0);
    setGameOver(false);
    setMovesLeft(20);
  }, [rows, cols]);

  // ÁªÑ‰ª∂ÊåÇËΩΩÊó∂ÂàùÂßãÂåñÊ∏∏Êàè
  useEffect(() => {
    initializeBoard();
  }, [initializeBoard]);

  // Ê£ÄÊü•‰∏§‰∏™ÊñπÂùóÊòØÂê¶Áõ∏ÈÇª
  const areBlocksAdjacent = (block1: Block, block2: Block): boolean => {
    // Ê∞¥Âπ≥Áõ∏ÈÇª
    if (Math.abs(block1.x - block2.x) === 1 && block1.y === block2.y) {
      return true;
    }
    // ÂûÇÁõ¥Áõ∏ÈÇª
    if (Math.abs(block1.y - block2.y) === 1 && block1.x === block2.x) {
      return true;
    }
    // ÂØπËßíÁ∫øÁõ∏ÈÇª
    if (Math.abs(block1.x - block2.x) === 1 && Math.abs(block1.y - block2.y) === 1) {
      return true;
    }
    return false;
  };

  // Ê£ÄÊü•ÊñπÂùóÊòØÂê¶ÂèØ‰ª•Ë¢´ÈÄâ‰∏≠
  const canSelectBlock = (block: Block): boolean => {
    // ÂΩ©ËôπÊñπÂùóÂèØ‰ª•‰∏é‰ªª‰ΩïÊñπÂùóËøûÊé•
    if (block.special === 'rainbow') {
      return true;
    }
    
    // Â¶ÇÊûúÊ≤°ÊúâÈÄâ‰∏≠ÁöÑÊñπÂùóÔºå‰ªª‰ΩïÊñπÂùóÈÉΩÂèØ‰ª•Ë¢´ÈÄâ‰∏≠
    if (selectedBlocks.length === 0) {
      return true;
    }
    
    const lastSelected = selectedBlocks[selectedBlocks.length - 1];
    
    // ÂΩ©ËôπÊñπÂùóÂèØ‰ª•‰∏é‰ªª‰ΩïÊñπÂùóËøûÊé•
    if (lastSelected.special === 'rainbow') {
      return true;
    }
    
    // Ê£ÄÊü•ÊòØÂê¶Áõ∏ÈÇª
    if (!areBlocksAdjacent(block, lastSelected)) {
      return false;
    }
    
    // Ê£ÄÊü•Á±ªÂûãÊòØÂê¶Áõ∏Âêå
    return block.type === lastSelected.type;
  };

  // Â§ÑÁêÜÊñπÂùóÁÇπÂáª
  const handleBlockClick = (block: Block) => {
    if (gameOver) return;
    
    // Â¶ÇÊûúÊñπÂùóÂ∑≤ÁªèË¢´ÈÄâ‰∏≠ÔºåÂèñÊ∂àÈÄâÊã©Èìæ‰∏≠ËØ•ÊñπÂùó‰πãÂêéÁöÑÊâÄÊúâÊñπÂùó
    const index = selectedBlocks.findIndex(b => b.id === block.id);
    if (index !== -1) {
      const newSelectedBlocks = selectedBlocks.slice(0, index + 1);
      setSelectedBlocks(newSelectedBlocks);
      
      // Êõ¥Êñ∞ÊñπÂùóÈÄâ‰∏≠Áä∂ÊÄÅ
      setBlocks(blocks.map(b => ({
        ...b,
        selected: newSelectedBlocks.some(selected => selected.id === b.id)
      })));
      
      return;
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÈÄâ‰∏≠
    if (!canSelectBlock(block)) {
      return;
    }
    
    // Ê∑ªÂä†Âà∞ÈÄâ‰∏≠ÂàóË°®
    const newSelectedBlocks = [...selectedBlocks, block];
    setSelectedBlocks(newSelectedBlocks);
    
    // Êõ¥Êñ∞ÊñπÂùóÈÄâ‰∏≠Áä∂ÊÄÅ
    setBlocks(blocks.map(b => ({
      ...b,
      selected: newSelectedBlocks.some(selected => selected.id === b.id)
    })));
  };

  // Â§ÑÁêÜÊñπÂùóËøûÁ∫øÂÆåÊàê
  const handleLineComplete = () => {
    if (selectedBlocks.length < 3) {
      // ÂèñÊ∂àÈÄâÊã©
      setSelectedBlocks([]);
      setBlocks(blocks.map(b => ({ ...b, selected: false })));
      return;
    }
    
    // ËÆ°ÁÆóÂæóÂàÜ
    const baseScore = selectedBlocks.length * 10;
    const comboMultiplier = Math.max(1, combo * 0.5);
    const specialBonus = selectedBlocks.reduce((bonus, block) => {
      if (block.special === 'bomb') return bonus + 50;
      if (block.special === 'rainbow') return bonus + 30;
      if (block.special === 'line') return bonus + 40;
      return bonus;
    }, 0);
    
    const totalScore = Math.floor((baseScore + specialBonus) * comboMultiplier);
    
    // Êõ¥Êñ∞ÂàÜÊï∞
    const newScore = score + totalScore;
    setScore(newScore);
    onScoreChange(newScore);
    
    // Êõ¥Êñ∞ËøûÂáª
    const newCombo = combo + 1;
    setCombo(newCombo);
    
    // Êõ¥Êñ∞ËÉΩÈáè
    const energyGain = selectedBlocks.length * 2;
    const newEnergy = Math.min(100, energy + energyGain);
    setEnergy(newEnergy);
    onEnergyChange(newEnergy);
    
    // Â§ÑÁêÜÁâπÊÆäÊñπÂùóÊïàÊûú
    let blocksToRemove: Block[] = [...selectedBlocks];
    
    selectedBlocks.forEach(block => {
      if (block.special === 'bomb') {
        // ÁÇ∏ÂºπÊïàÊûúÔºöÊ∂àÈô§Âë®Âõ¥ÁöÑÊñπÂùó
        blocks.forEach(b => {
          if (Math.abs(b.x - block.x) <= 1 && Math.abs(b.y - block.y) <= 1) {
            if (!blocksToRemove.some(rb => rb.id === b.id)) {
              blocksToRemove.push(b);
            }
          }
        });
      } else if (block.special === 'line') {
        // Áõ¥Á∫øÊ∂àÈô§ÔºöÊ∂àÈô§Âêå‰∏ÄË°åÊàñÂêå‰∏ÄÂàóÁöÑÊñπÂùó
        blocks.forEach(b => {
          if (b.x === block.x || b.y === block.y) {
            if (!blocksToRemove.some(rb => rb.id === b.id)) {
              blocksToRemove.push(b);
            }
          }
        });
      }
    });
    
    // ÁßªÈô§ÊñπÂùóÂπ∂ÁîüÊàêÊñ∞ÊñπÂùó
    const newBlocks = blocks.filter(b => !blocksToRemove.some(rb => rb.id === b.id));
    
    // ÁîüÊàêÊñ∞ÊñπÂùó
    let maxId = blocks.reduce((max, block) => Math.max(max, block.id), 0);
    const addedBlocks: Block[] = [];
    
    // ËÆ°ÁÆóÊØèÂàóÈúÄË¶ÅÊ∑ªÂä†ÁöÑÊñπÂùóÊï∞Èáè
    const columnsToFill: { [key: number]: number } = {};
    blocksToRemove.forEach(block => {
      columnsToFill[block.x] = (columnsToFill[block.x] || 0) + 1;
    });
    
    // Ê∑ªÂä†Êñ∞ÊñπÂùó
    Object.entries(columnsToFill).forEach(([colStr, count]) => {
      const col = parseInt(colStr);
      for (let i = 0; i < count; i++) {
        const type = Math.floor(Math.random() * 6);
        
        // ÈöèÊú∫ÁîüÊàêÁâπÊÆäÊñπÂùó
        let special: SpecialType = null;
        const specialRand = Math.random();
        if (specialRand < 0.02) {
          special = 'bomb';
        } else if (specialRand < 0.04) {
          special = 'rainbow';
        } else if (specialRand < 0.05) {
          special = 'line';
        }
        
        addedBlocks.push({
          id: ++maxId,
          type,
          special,
          x: col,
          y: -i - 1, // ‰ªéÈ°∂ÈÉ®ËêΩ‰∏ã
          selected: false
        });
      }
    });
    
    // Êõ¥Êñ∞Ê∏∏ÊàèÈù¢Êùø
    setBlocks([...newBlocks, ...addedBlocks]);
    setSelectedBlocks([]);
    
    // ÂáèÂ∞ëÂâ©‰ΩôÊ≠•Êï∞
    const newMovesLeft = movesLeft - 1;
    setMovesLeft(newMovesLeft);
    
    // Ê£ÄÊü•Ê∏∏ÊàèÊòØÂê¶ÁªìÊùü
    if (newMovesLeft <= 0) {
      setGameOver(true);
    }
  };

  // ‰ΩøÁî®ËÉΩÈáèÁàÜÂèë
  const useEnergyBurst = () => {
    if (energy < 100 || gameOver) return;
    
    // ÈöèÊú∫ÁßªÈô§30%ÁöÑÊñπÂùó
    const blocksToRemove: Block[] = [];
    const blockCount = Math.floor(blocks.length * 0.3);
    
    for (let i = 0; i < blockCount; i++) {
      const randomIndex = Math.floor(Math.random() * blocks.length);
      if (!blocksToRemove.some(b => b.id === blocks[randomIndex].id)) {
        blocksToRemove.push(blocks[randomIndex]);
      }
    }
    
    // ËÆ°ÁÆóÂæóÂàÜ
    const burstScore = blockCount * 20;
    const newScore = score + burstScore;
    setScore(newScore);
    onScoreChange(newScore);
    
    // ÈáçÁΩÆËÉΩÈáè
    setEnergy(0);
    onEnergyChange(0);
    
    // ÁßªÈô§ÊñπÂùóÂπ∂ÁîüÊàêÊñ∞ÊñπÂùó
    const newBlocks = blocks.filter(b => !blocksToRemove.some(rb => rb.id === b.id));
    
    // ÁîüÊàêÊñ∞ÊñπÂùó
    let maxId = blocks.reduce((max, block) => Math.max(max, block.id), 0);
    const addedBlocks: Block[] = [];
    
    // ËÆ°ÁÆóÊØèÂàóÈúÄË¶ÅÊ∑ªÂä†ÁöÑÊñπÂùóÊï∞Èáè
    const columnsToFill: { [key: number]: number } = {};
    blocksToRemove.forEach(block => {
      columnsToFill[block.x] = (columnsToFill[block.x] || 0) + 1;
    });
    
    // Ê∑ªÂä†Êñ∞ÊñπÂùó
    Object.entries(columnsToFill).forEach(([colStr, count]) => {
      const col = parseInt(colStr);
      for (let i = 0; i < count; i++) {
        const type = Math.floor(Math.random() * 6);
        
        // ÈöèÊú∫ÁîüÊàêÁâπÊÆäÊñπÂùó
        let special: SpecialType = null;
        const specialRand = Math.random();
        if (specialRand < 0.02) {
          special = 'bomb';
        } else if (specialRand < 0.04) {
          special = 'rainbow';
        } else if (specialRand < 0.05) {
          special = 'line';
        }
        
        addedBlocks.push({
          id: ++maxId,
          type,
          special,
          x: col,
          y: -i - 1, // ‰ªéÈ°∂ÈÉ®ËêΩ‰∏ã
          selected: false
        });
      }
    });
    
    // Êõ¥Êñ∞Ê∏∏ÊàèÈù¢Êùø
    setBlocks([...newBlocks, ...addedBlocks]);
  };

  // ÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
  const restartGame = () => {
    initializeBoard();
  };

  // Ê∏≤ÊüìÊñπÂùó
  const renderBlock = (block: Block) => {
    const style = {
      backgroundColor: colorMap[block.type],
      border: block.selected ? '2px solid white' : '1px solid rgba(255, 255, 255, 0.3)',
      boxShadow: block.selected ? '0 0 10px white' : 'none',
    };
    
    return (
      <div
        key={block.id}
        className={`block ${block.selected ? 'selected' : ''}`}
        style={style}
        onClick={() => handleBlockClick(block)}
      >
        {block.special && <div className="special-icon">{specialIcons[block.special as keyof typeof specialIcons]}</div>}
      </div>
    );
  };

  return (
    <div className="game-container">
      <div className="game-info">
        <div className="score">ÂàÜÊï∞: {score}</div>
        <div className="moves">Ââ©‰ΩôÊ≠•Êï∞: {movesLeft}</div>
        <div className="combo">ËøûÂáª: {combo}x</div>
      </div>
      
      <div className="energy-bar-container">
        <div className="energy-bar" style={{ width: `${energy}%` }}></div>
        <button 
          className={`energy-burst-button ${energy < 100 ? 'disabled' : ''}`}
          onClick={useEnergyBurst}
          disabled={energy < 100}
        >
          ËÉΩÈáèÁàÜÂèë
        </button>
      </div>
      
      <div className="game-board" style={{ gridTemplateColumns: `repeat(${cols}, 1fr)` }}>
        {blocks.map(block => renderBlock(block))}
      </div>
      
      <div className="game-controls">
        <button className="control-button" onClick={handleLineComplete}>ÂÆåÊàêËøûÁ∫ø</button>
        <button className="control-button" onClick={() => {
          setSelectedBlocks([]);
          setBlocks(blocks.map(b => ({ ...b, selected: false })));
        }}>ÂèñÊ∂àÈÄâÊã©</button>
      </div>
      
      {gameOver && (
        <div className="game-over-overlay">
          <div className="game-over-modal">
            <h2>Ê∏∏ÊàèÁªìÊùü</h2>
            <p>ÊúÄÁªàÂæóÂàÜ: {score}</p>
            <button onClick={restartGame}>ÈáçÊñ∞ÂºÄÂßã</button>
          </div>
        </div>
      )}
    </div>
  );
};

export default GameBoard;
